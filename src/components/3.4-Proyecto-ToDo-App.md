# ToDo App con React, Context API y Custom Hooks en TypeScript

Este proyecto es una aplicación de lista de tareas (ToDo App) desarrollada con React y TypeScript. Su principal objetivo es demostrar una gestión de estado moderna, escalable y desacoplada utilizando la **API de Context de React** y **Custom Hooks**.

## Arquitectura del Código

La aplicación se estructura en cuatro partes principales que trabajan en conjunto para gestionar el estado y la interfaz de usuario:

1.  **Tipos de TypeScript**: Definen la estructura de nuestros datos.
2.  **Custom Hook (`useTodos`)**: Encapsula toda la lógica de negocio y el estado.
3.  **Context (`TodoContext`, `TodoProvider`, `useTodoContext`)**: Distribuye el estado y la lógica a través de la aplicación.
4.  **Componentes (`TodoInput`, `TodoList`, `ProyectoToDoApp`)**: Construyen la interfaz de usuario y consumen el estado del contexto.

---

### 1. Tipos (TypeScript)

Para asegurar la consistencia y prevenir errores, se utilizan interfaces de TypeScript para definir la "forma" de nuestros datos.

```typescript
// Define la estructura de un objeto de tarea.
interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

// Define la estructura del valor que nuestro Context proveerá.
interface TodoContextType {
  todos: Todo[];
  addTodo: (text: string) => void;
  toggleTodo: (id: number) => void;
  removeTodo: (id: number) => void;
}
```

-   **`Todo`**: Representa una única tarea con su `id`, `text` y estado `completed`.
-   **`TodoContextType`**: Describe el objeto que nuestro `Context` compartirá, incluyendo el array de tareas y las funciones para manipularlo.

---

### 2. Custom Hook (`useTodos`)

Un **Custom Hook** es una función reutilizable que extrae la lógica de un componente. En este caso, `useTodos` centraliza toda la gestión del estado de las tareas.

```typescript
function useTodos(): TodoContextType {
  const [todos, setTodos] = useState<Todo[]>([]);

  const addTodo = (text: string) =>
    setTodos([...todos, { id: Date.now(), text, completed: false }]);

  const toggleTodo = (id: number) =>
    setTodos(
      todos.map((todo) =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    );

  const removeTodo = (id: number) =>
    setTodos(todos.filter((todo) => todo.id !== id));

  return { todos, addTodo, toggleTodo, removeTodo };
}
```

-   **`useState<Todo[]>`**: Inicializa el estado `todos` como un array vacío, especificando que contendrá objetos de tipo `Todo`.
-   **`addTodo`**: Añade una nueva tarea al estado.
-   **`toggleTodo`**: Cambia el estado `completed` de una tarea específica.
-   **`removeTodo`**: Elimina una tarea del estado.
-   El hook devuelve un objeto que cumple con la interfaz `TodoContextType`, conteniendo tanto el estado como las funciones para modificarlo.

---

### 3. Context

La **API de Context** de React permite compartir datos "globales" a un árbol de componentes sin necesidad de pasar `props` manualmente a través de cada nivel (evitando el "prop drilling").

#### `TodoContext` y `TodoProvider`

```typescript
const TodoContext = createContext<TodoContextType | null>(null);

function TodoProvider({ children }: { children: ReactNode }) {
  const todoLogic = useTodos(); // Obtiene la lógica y el estado del Custom Hook.
  return (
    // Provee 'todoLogic' a todos los componentes hijos.
    <TodoContext.Provider value={todoLogic}>
      {children}
    </TodoContext.Provider>
  );
}
```

-   **`createContext`**: Crea un objeto Context. Se inicializa con `null` y se le asigna el tipo `TodoContextType | null`.
-   **`TodoProvider`**: Es un componente "envoltorio" o *wrapper*.
    1.  Llama al `custom hook` `useTodos()` para obtener el estado y las funciones.
    2.  Utiliza `TodoContext.Provider` para hacer que este valor (`todoLogic`) esté disponible para todos los componentes que envuelve (`children`).

#### `useTodoContext`

Este es un hook personalizado que simplifica el acceso al contexto y añade una capa de seguridad.

```typescript
function useTodoContext() {
  const context = useContext(TodoContext);
  if (!context) {
    throw new Error("useTodoContext debe usarse dentro de TodoProvider");
  }
  return context;
}
```

-   **`useContext(TodoContext)`**: Accede al valor proporcionado por el `TodoProvider`.
-   **Verificación de seguridad**: Si el hook se usa fuera de un `TodoProvider`, el contexto será `null`. En ese caso, se lanza un error descriptivo para facilitar la depuración. Esto asegura que los componentes siempre reciban los datos que esperan.

---

### 4. Componentes

Los componentes de la interfaz de usuario están diseñados para ser "tontos" (o de presentación), ya que su única responsabilidad es mostrar la UI e invocar las funciones del contexto.

#### `TodoInput`

Muestra el campo de texto y el botón para añadir nuevas tareas.

```typescript
function TodoInput() {
  const { addTodo } = useTodoContext(); // Consume solo la función que necesita.
  // ... resto de la lógica ...
}
```

-   Llama a `useTodoContext()` para obtener la función `addTodo` y la utiliza para crear una nueva tarea.

#### `TodoList`

Muestra la lista de tareas y permite interactuar con ellas (marcarlas como completadas o eliminarlas).

```typescript
function TodoList() {
  // Consume el estado 'todos' y las funciones para interactuar.
  const { todos, toggleTodo, removeTodo } = useTodoContext();
  // ... resto de la lógica ...
}
```

-   Recibe el array `todos` y lo mapea para renderizar cada tarea.
-   Los botones y el texto de cada tarea utilizan `toggleTodo` y `removeTodo` del contexto para modificar el estado global.

#### `ProyectoToDoApp` (Componente principal)

Es el componente que ensambla toda la aplicación.

```typescript
export default function ProyectoToDoApp() {
  return (
    <TodoProvider>
      <h1>ToDo App con Context y Custom Hooks</h1>
      <TodoInput />
      <TodoList />
    </TodoProvider>
  );
}
```

-   La clave aquí es que **`TodoProvider` envuelve a todos los componentes que necesitan acceso al estado de las tareas**. Gracias a esto, `TodoInput` y `TodoList` pueden usar `useTodoContext()` para acceder a los datos compartidos sin que `ProyectoToDoApp` tenga que pasárselos como `props`.

## Flujo de Datos

1.  El `TodoProvider` se inicializa y llama a `useTodos()`, creando el estado inicial de las tareas.
2.  `TodoProvider` pone el estado y las funciones de `useTodos()` en el `Context`.
3.  `TodoList` usa `useTodoContext()` para leer el array `todos` y mostrar la lista.
4.  El usuario escribe en el `TodoInput` y hace clic en "Agregar".
5.  `TodoInput` llama a la función `addTodo()` que obtuvo del contexto.
6.  La función `addTodo` (dentro de `useTodos`) actualiza el estado `todos` llamando a `setTodos`.
7.  El cambio de estado provoca que React vuelva a renderizar los componentes que consumen ese estado.
8.  `TodoList` recibe el nuevo array `todos` actualizado y muestra la nueva tarea en la lista.