# ToDo App con React, Context API y Custom Hooks en TypeScript

## Tabla de Contenidos
- [Arquitectura del Código](#arquitectura-del-código)
- [1. Tipos (TypeScript)](#1-tipos-typescript)
- [2. Custom Hook (`useTodos`)](#2-custom-hook-usetodos)
- [3. Context y Provider](#3-context-y-provider)
- [4. Componentes](#4-componentes)
- [5. Flujo de Datos en Acción](#5-flujo-de-datos-en-acción)

Este proyecto es una aplicación de lista de tareas (ToDo App) desarrollada con React y TypeScript. Su principal objetivo es demostrar una gestión de estado moderna, escalable y desacoplada utilizando la **API de Context de React** y **Custom Hooks**.

## Arquitectura del Código

La aplicación se estructura en cuatro partes principales que trabajan en conjunto para gestionar el estado y la interfaz de usuario:

1.  **Tipos de TypeScript**: Definen la estructura de nuestros datos.
2.  **Custom Hook (`useTodos`)**: Encapsula toda la lógica de negocio y el estado.
3.  **Context (`TodoContext`, `TodoProvider`, `useTodoContext`)**: Distribuye el estado y la lógica a través de la aplicación.
4.  **Componentes (`TodoInput`, `TodoList`, `ProyectoToDoApp`)**: Construyen la interfaz de usuario y consumen el estado del contexto.

---

# 1 Tipos (TypeScript)

Para asegurar la consistencia y prevenir errores, se utilizan interfaces de TypeScript para definir la "forma" de nuestros datos.

```typescript
// Define la estructura de un objeto de tarea.
interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

// Define la estructura del valor que nuestro Context proveerá.
interface TodoContextType {
  todos: Todo[];
  addTodo: (text: string) => void;
  toggleTodo: (id: number) => void;
  removeTodo: (id: number) => void;
}
```

-   **`Todo`**: Representa una única tarea con su `id`, `text` y estado `completed`.
-   **`TodoContextType`**: Describe el objeto que nuestro `Context` compartirá, incluyendo el array de tareas y las funciones para manipularlo.

---

# 2 Custom Hook (`useTodos`)

Un **Custom Hook** es una función reutilizable que extrae la lógica de un componente. En este caso, `useTodos` centraliza toda la gestión del estado de las tareas.

```typescript
function useTodos(): TodoContextType {
  const [todos, setTodos] = useState<Todo[]>([]);

  const addTodo = (text: string) =>
    setTodos([...todos, { id: Date.now(), text, completed: false }]);

  const toggleTodo = (id: number) =>
    setTodos(
      todos.map((todo) =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    );

  const removeTodo = (id: number) =>
    setTodos(todos.filter((todo) => todo.id !== id));

  return { todos, addTodo, toggleTodo, removeTodo };
}
```

-   **`useState<Todo[]>`**: Inicializa el estado `todos` como un array vacío, especificando que contendrá objetos de tipo `Todo`.
-   **`addTodo`**: Añade una nueva tarea al estado.
-   **`toggleTodo`**: Cambia el estado `completed` de una tarea específica.
-   **`removeTodo`**: Elimina una tarea del estado.
-   El hook devuelve un objeto que cumple con la interfaz `TodoContextType`, conteniendo tanto el estado como las funciones para modificarlo.

---

# 3 Context y el Provider
Analicemos en detalle esa sección, ya que es el corazón de la arquitectura de Context en tu aplicación. Combina la creación del "canal" de datos, la obtención de los datos reales y la forma de distribuirlos.

---

Este bloque de código tiene dos responsabilidades principales:
1.  **Crear el Contexto**: Un "contenedor" o "canal" vacío que existirá a nivel de la aplicación.
2.  **Crear el Proveedor (Provider)**: Un componente especial que llenará ese contenedor con datos y lo hará accesible para otros componentes.

---

### Parte 1: `const TodoContext = createContext<TodoContextType | null>(null);`

Esta línea crea el objeto de Contexto. Vamos a desglosarla pieza por pieza:

1.  **`createContext()`**:
    *   Es una función que viene directamente de la librería de React.
    *   Su propósito es crear un objeto que contiene dos componentes: un `Provider` y un `Consumer`. En la práctica moderna con hooks, principalmente usamos el `Provider` y el hook `useContext` en lugar del `Consumer`.
    *   Piensa en esto como crear una "emisora de radio" vacía. Aún no está transmitiendo nada, pero la frecuencia (`TodoContext`) ya existe.

2.  **`<TodoContextType | null>` (El Genérico de TypeScript)**:
    *   Esta es una anotación de tipo de TypeScript que define qué "forma" puede tener el valor dentro de este contexto.
    *   **`TodoContextType`**: Es la `interface` que definiste, la cual describe el objeto ideal que queremos compartir: `{ todos: [], addTodo: fn, ... }`.
    *   **`| null` (Tipo de Unión)**: El símbolo `|` crea un "tipo de unión". Esto significa que el valor del contexto puede ser de tipo `TodoContextType` **O** puede ser `null`.
    *   **¿Por qué necesitamos `| null`?** La respuesta está en la siguiente parte...

3.  **`(null)` (El Valor por Defecto)**:
    *   El argumento que pasas a `createContext()` es el **valor por defecto**.
    *   Este es el valor que un componente recibirá si intenta consumir este contexto **pero no se encuentra dentro de un `TodoProvider` que le dé un valor real**.
    *   Como le estamos dando un valor inicial de `null`, debemos decirle a TypeScript que `null` es un valor posible para este contexto. De ahí la necesidad de `<TodoContextType | null>`. Es una forma de mantener la coherencia entre el valor por defecto y los tipos permitidos.

**En resumen, esta línea crea un "canal" llamado `TodoContext` que está diseñado para transportar datos con la forma de `TodoContextType`, pero que por defecto no transporta nada (`null`).**

---

### Parte 2: El Componente `TodoProvider`

Este es el componente que realmente le da vida y utilidad a nuestro contexto. Su única misión es "proveer" el valor a todos los componentes que envuelve.

```typescript
function TodoProvider({ children }: { children: ReactNode }) {
  // 1. Obtiene la lógica y el estado del Custom Hook.
  const todoLogic = useTodos(); 
  
  return (
    // 2. Utiliza el Provider del contexto creado anteriormente.
    <TodoContext.Provider value={todoLogic}>
      {/* 3. Renderiza cualquier componente hijo que se le pase. */}
      {children}
    </TodoContext.Provider>
  );
}
```

Vamos a analizar sus responsabilidades:

1.  **Obtener los Datos Reales: `const todoLogic = useTodos();`**
    *   Aquí es donde la magia ocurre. En lugar de definir la lógica del estado dentro del `Provider`, la delegamos al `custom hook` `useTodos()`.
    *   `useTodos()` se ejecuta y nos devuelve el objeto con el estado actual (`todos`) y las funciones para manipularlo (`addTodo`, `toggleTodo`, `removeTodo`). Este objeto, `todoLogic`, es la "fuente de la verdad".
    *   Esto es un excelente ejemplo de **separación de responsabilidades**: `useTodos` se encarga de la *lógica*, y `TodoProvider` se encarga de la *distribución*.

2.  **Usar el Componente `Provider`: `<TodoContext.Provider value={todoLogic}>`**
    *   Cada contexto que creamos (`TodoContext`) viene con un componente `Provider` asociado.
    *   Este componente tiene una `prop` **esencial**: `value`.
    *   El valor que le pases a la `prop` `value` será el que estará disponible para todos los componentes descendientes que consuman este contexto.
    *   Aquí, le estamos pasando `value={todoLogic}`, por lo que el estado y las funciones de nuestro hook ahora están siendo "transmitidos" a través del canal `TodoContext`.

3.  **Renderizar los Hijos: `{children}`**
    *   **`{ children }`**: Es una `prop` especial en React. Representa a todos los componentes o elementos JSX que anidas *dentro* del `TodoProvider` cuando lo usas. Por ejemplo:
        ```jsx
        <TodoProvider>
          <App /> {/* App es el `children` */}
        </TodoProvider>
        ```
    *   **`: { children: ReactNode }`**: Esta es la anotación de tipo para las `props`. `ReactNode` es un tipo de React que representa cualquier cosa que React puede renderizar (componentes, strings, números, etc.).
    *   Al renderizar `{children}` *dentro* del `Provider`, nos aseguramos de que toda la aplicación (o la parte de ella que envolvimos) esté "dentro del rango de la señal" y pueda acceder al valor del contexto.

### Analogía para Entenderlo Mejor

Imagina que quieres poner música en toda tu casa:

1.  **`createContext()`**: Es como **instalar el sistema de altavoces** en las paredes de toda la casa. Los altavoces están ahí (`TodoContext`), pero están en silencio por defecto (`null`).

2.  **`useTodos()`**: Es tu **reproductor de música** (como Spotify o un tocadiscos). Contiene las canciones (`todos`) y los controles de reproducción (`addTodo`, `removeTodo`, etc.).

3.  **`TodoProvider`**: Es el **amplificador central**.
    *   Se conecta al reproductor de música (`const todoLogic = useTodos()`).
    *   Toma la señal de audio (`todoLogic`) y la envía a todo el sistema de altavoces (`value={todoLogic}`).
    *   Las habitaciones de la casa (`children`) están dentro del rango del amplificador.

Cualquier persona en cualquier habitación (`componente hijo`) ahora puede usar un control remoto (`useTodoContext()`) para escuchar y controlar la música que el amplificador central está transmitiendo.



---

# 4 Componentes

¡Perfecto! Analicemos en detalle estos tres componentes. Son la parte visible de la aplicación y demuestran cómo se consume y se interactúa con el estado global que hemos preparado con el Context y el Custom Hook.

---

### Explicación Detallada de los Componentes de React

Estos tres componentes (`TodoInput`, `TodoList` y `ProyectoToDoApp`) trabajan juntos para construir la interfaz de usuario (UI). Su principal característica es que están **desacoplados** de la lógica de negocio; no saben *cómo* se añaden o eliminan las tareas, solo saben que deben llamar a unas funciones que reciben del contexto.

---

### 1. `ProyectoToDoApp` (El Componente Orquestador)

```javascript
export default function ProyectoToDoApp() {
  return (
    <TodoProvider>
      <h4>ToDo App con Context y Custom Hooks</h4>
      <TodoInput />
      <TodoList />
    </TodoProvider>
  );
}
```

Este es el componente principal que ensambla la aplicación. Su rol es estructural y fundamental.

**Responsabilidades Clave:**

1.  **Establecer el Contexto**: La tarea más importante de este componente es usar `<TodoProvider>`. Al envolver `TodoInput` y `TodoList` dentro de `<TodoProvider>`, está garantizando que ambos componentes (y cualquier otro que pudiera estar anidado más adentro) tengan acceso al estado compartido (la lista de `todos` y las funciones para manipularla).
2.  **Componer la Interfaz**: Simplemente renderiza los diferentes bloques que forman la aplicación: un título, el campo de entrada de tareas y la lista de tareas.

**¿Por qué es tan importante?**

Sin `<TodoProvider>` aquí, si `TodoInput` o `TodoList` intentaran llamar a `useTodoContext()`, la aplicación fallaría con el error que definimos: `"useTodoContext debe usarse dentro de TodoProvider"`. Este componente actúa como el "proveedor de señal" para todos los componentes que la necesiten.

---

### 2. `TodoInput` (El Componente de Entrada de Datos)

```javascript
function TodoInput() {
  // 1. Conexión al estado global
  const { addTodo } = useTodoContext();
  
  // 2. Estado local para el campo de texto
  const [text, setText] = useState("");

  const handleAdd = () => {
    // 3. Lógica del evento
    if (text.trim()) { // Evita añadir tareas vacías
      addTodo(text);   // Llama a la función del contexto
      setText("");     // Limpia el campo de texto local
    }
  };

  return (
    // 4. Renderizado de la UI
    <div>
      <input
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="Nueva tarea"
      />
      <button onClick={handleAdd}>Agregar</button>
    </div>
  );
}
```

Este componente se encarga de capturar la entrada del usuario para crear nuevas tareas.

**Análisis Detallado:**

1.  **Conexión al Contexto**: `const { addTodo } = useTodoContext();`
    *   Llama al hook `useTodoContext()` para "conectarse" al `TodoProvider` más cercano en el árbol de componentes.
    *   Utiliza la desestructuración (`{ addTodo }`) para extraer únicamente la función `addTodo`. Este componente no necesita ver la lista de tareas, solo necesita la capacidad de añadir una nueva. Es una buena práctica pedir solo lo que necesitas.

2.  **Estado Local**: `const [text, setText] = useState("");`
    *   Este es un **estado local**, exclusivo del componente `TodoInput`. No es compartido con el resto de la aplicación.
    *   Su única finalidad es controlar el valor del campo `<input>`. Esto es un patrón muy común en React llamado **"Controlled Component"** (Componente Controlado), donde el estado de React es la "única fuente de la verdad" para el valor del input.

3.  **Manejador de Eventos**: `const handleAdd = () => { ... }`
    *   Esta función se ejecuta cuando el usuario hace clic en el botón "Agregar".
    *   Primero, valida que el texto no esté vacío usando `text.trim()`.
    *   Luego, ejecuta `addTodo(text)`. Aquí está la magia: **invoca la función que recibió del contexto global**, pasándole el texto del estado local. Esto actualiza el estado centralizado de la aplicación.
    *   Finalmente, llama a `setText("")` para limpiar el estado local, lo que a su vez vacía el campo de texto en la pantalla, preparándolo para la siguiente tarea.

4.  **Renderizado (JSX)**:
    *   `value={text}`: Vincula el valor visible del input directamente al estado `text`.
    *   `onChange={(e) => setText(e.target.value)}`: Cada vez que el usuario teclea algo, este evento se dispara, actualizando el estado `text` con el nuevo valor del input. Esto es lo que hace que sea un componente controlado.
    *   `onClick={handleAdd}`: Asocia la función `handleAdd` al evento `click` del botón.

---

### 3. `TodoList` (El Componente de Visualización)

```javascript
function TodoList() {
  // 1. Conexión al estado global
  const { todos, toggleTodo, removeTodo } = useTodoContext();
  
  return (
    // 2. Renderizado de la lista
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>
          <span
            onClick={() => toggleTodo(todo.id)}
            style={{
              textDecoration: todo.completed ? "line-through" : "none",
            }}
          >
            {todo.text}
          </span>
          <button onClick={() => removeTodo(todo.id)}>X</button>
        </li>
      ))}
    </ul>
  );
}
```

Este componente es responsable de mostrar la lista de tareas y permitir que el usuario interactúe con ellas.

**Análisis Detallado:**

1.  **Conexión al Contexto**: `const { todos, toggleTodo, removeTodo } = useTodoContext();`
    *   Al igual que `TodoInput`, se conecta al contexto. Sin embargo, este componente necesita más piezas:
        *   `todos`: El array de datos para poder mostrar la lista.
        *   `toggleTodo` y `removeTodo`: Las funciones para poder modificar o eliminar las tareas existentes.

2.  **Renderizado de la Lista**:
    *   `{todos.map((todo) => (...))}`: Este es el método estándar en React para renderizar una lista de elementos a partir de un array. El método `.map()` de JavaScript itera sobre cada elemento `todo` en el array `todos` y devuelve un elemento JSX (`<li>`) por cada uno.
    *   `<li key={todo.id}>`: La `prop` `key` es **crucial** para React. Ayuda a React a identificar qué elementos de la lista han cambiado, han sido añadidos o eliminados de manera eficiente. El `key` debe ser un identificador único y estable para cada elemento, y el `todo.id` es perfecto para ello.
    *   `onClick={() => toggleTodo(todo.id)}`: Cuando el usuario hace clic en el texto de la tarea, se llama a la función `toggleTodo` del contexto, pasándole el `id` de la tarea específica que fue clickeada. Se usa una función de flecha `() => ...` para asegurar que `toggleTodo` solo se ejecute en el momento del clic.
    *   `style={{...}}`: Este es un ejemplo de estilo dinámico. Usa un operador ternario para cambiar el estilo del texto: si `todo.completed` es `true`, aplica el tachado (`line-through`); si no, no aplica decoración. Esto proporciona feedback visual inmediato al usuario.
    *   `<button onClick={() => removeTodo(todo.id)}>X</button>`: De forma similar, el botón de eliminar llama a la función `removeTodo` del contexto con el `id` correspondiente para borrar esa tarea del estado global.

### Flujo de Datos en Acción

1.  **Añadir Tarea**: Usuario escribe en `TodoInput` -> Clic en "Agregar" -> `handleAdd` llama a `addTodo(text)` del contexto -> El estado en `useTodos` se actualiza -> React detecta el cambio de estado -> `TodoList` se vuelve a renderizar con la nueva lista de `todos`.
2.  **Marcar Tarea**: Usuario hace clic en el texto de una tarea en `TodoList` -> `onClick` llama a `toggleTodo(id)` del contexto -> El estado en `useTodos` se actualiza -> `TodoList` se vuelve a renderizar y el estilo del `<span>` cambia.