### Parte 1: Creando el Contexto

```javascript
import React, { createContext, useContext, useState } from "react";
```
*   **`import React, ...`**: Como siempre, importamos la librería base de React y el Hook `useState`.
*   **`createContext`**: Esta es una función de React que nos permite crear un objeto "Context". Piensa en este objeto como un **canal de comunicación global** para una parte de tu aplicación.
*   **`useContext`**: Este es un Hook que permite a un componente "suscribirse" a un Contexto y leer el valor que este transporta.

```javascript
const ThemeContext = createContext();
```
*   **`const ThemeContext = createContext()`**: Aquí creamos nuestro canal de comunicación. `ThemeContext` es un objeto que contiene dos componentes principales: `Provider` y `Consumer`. En este ejemplo, usaremos el `Provider` explícitamente y el `Consumer` de forma implícita a través del Hook `useContext`.
*   Podríamos haber pasado un valor por defecto dentro de `createContext(valorPorDefecto)`, pero no es necesario aquí porque siempre vamos a usar un `Provider`.

---

### Parte 2: El Componente "Proveedor" (`ThemeProvider`)

Este es el componente que será el **dueño del estado** y lo **proveerá** a todos sus descendientes.

```javascript
function ThemeProvider({ children }) {
```
*   **`function ThemeProvider(...)`**: Creamos un componente funcional llamado `ThemeProvider`.
*   **`{ children }`**: Esta es una prop especial en React. `children` representa a todos los componentes que estarán anidados *dentro* de `<ThemeProvider>` cuando lo usemos. Es una forma de crear componentes "envoltorio" o "wrapper".

```javascript
  const [theme, setTheme] = useState("light");
  const toggleTheme = () =>
    setTheme((prev) => (prev === "light" ? "dark" : "light"));
```
*   **`const [theme, setTheme] = useState("light")`**: Aquí es donde vive el estado que queremos compartir. Creamos una variable de estado `theme` con un valor inicial de `"light"`.
*   **`const toggleTheme = () => ...`**: Creamos una función para cambiar el tema.
*   **`setTheme((prev) => ...)`**: Usamos la forma funcional de `setTheme`. En lugar de calcular el nuevo estado basándonos en el valor actual de `theme`, le pasamos una función que recibe el estado anterior (`prev`) y devuelve el nuevo. Es una práctica más segura para evitar problemas con estados que se actualizan muy rápido.
*   **`(prev === "light" ? "dark" : "light")`**: Este es un operador ternario. Es una forma corta de escribir un `if/else`: "Si el tema previo es 'light', devuelve 'dark'. Si no, devuelve 'light'".

```javascript
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}
```
*   **`return (...)`**: El `ThemeProvider` devuelve su JSX.
*   **`<ThemeContext.Provider ...>`**: Aquí usamos el componente `Provider` de nuestro contexto. **Todo lo que esté dentro de este Provider tendrá acceso al valor que le pasemos.**
*   **`value={{ theme, toggleTheme }}`**: Esta es la prop más importante del `Provider`. El valor que le pasemos aquí es el que estará disponible para todos los componentes descendientes. En este caso, pasamos un objeto que contiene:
    1.  `theme`: El valor actual del estado (ej. "light").
    2.  `toggleTheme`: La función que permite cambiar ese estado.
*   **`{children}`**: Aquí renderizamos los componentes hijos que nos pasaron. En nuestro caso, serán el `<h1>` y el `<ThemedButton>`.

---

### Parte 3: El Componente "Consumidor" (`ThemedButton`)

Este componente necesita acceder al estado del tema, pero está anidado dentro de `App`, que a su vez está dentro de `ThemeProvider`. Sin Context, tendríamos que pasar las props `theme` y `toggleTheme` a través de `App` hasta llegar a `ThemedButton` (prop drilling).

```javascript
function ThemedButton() {
  const { theme, toggleTheme } = useContext(ThemeContext);
```
*   **`const { theme, toggleTheme } = useContext(ThemeContext)`**: **Esta es la magia del Context API.**
*   **`useContext(ThemeContext)`**: Llamamos al Hook `useContext` y le pasamos el objeto `ThemeContext` que creamos al principio.
*   React busca en el árbol de componentes hacia arriba hasta encontrar el `<ThemeContext.Provider>` más cercano.
*   Una vez que lo encuentra, `useContext` devuelve el objeto completo que pasamos en la prop `value` de ese Provider.
*   **`const { theme, toggleTheme } = ...`**: Desestructuramos ese objeto para obtener acceso directo a la variable `theme` y a la función `toggleTheme` sin necesidad de props.

```javascript
  return (
    <button
      onClick={toggleTheme}
      style={{
        background: theme === "light" ? "#fff" : "#333",
        color: theme === "light" ? "#333" : "#fff",
        // ... otros estilos
      }}
    >
      Cambiar a {theme === "light" ? "Oscuro" : "Claro"}
    </button>
  );
}
```
*   El resto del componente ahora puede usar `theme` y `toggleTheme` como si fueran variables locales.
*   **`onClick={toggleTheme}`**: Al hacer clic, se llama directamente a la función que cambia el estado en el `ThemeProvider`.
*   **`style={{...}}`**: Los estilos del botón cambian dinámicamente basándose en el valor actual de la variable `theme`.
*   El texto del botón también cambia para reflejar la acción que realizará.

---

### Parte 4: La Aplicación Principal (`App`)

```javascript
export default function App() {
  return (
    <ThemeProvider>
      <h1>Context API</h1>
      <ThemedButton />
    </ThemeProvider>
  );
}
```
*   **`return (...)`**: El componente `App` simplemente renderiza la estructura.
*   **`<ThemeProvider>`**: Envolvemos toda la parte de la aplicación que necesita acceso al tema dentro de nuestro `ThemeProvider`.
*   **`<h1>` y `<ThemedButton />`**: Estos son los `children` que `ThemeProvider` renderizará.
*   Fíjate que `App` no sabe nada sobre el tema. No tiene estado, no tiene funciones. Actúa como un simple intermediario, pero gracias a Context, no necesita pasar ninguna prop relacionada con el tema hacia abajo.

### Resumen del Flujo

1.  **Creación:** Creamos un `ThemeContext` global.
2.  **Provisión:** El componente `ThemeProvider` crea el estado (`theme`) y la lógica para cambiarlo (`toggleTheme`). Luego, "provee" estos valores a todos sus hijos usando `<ThemeContext.Provider>`.
3.  **Consumo:** Cualquier componente descendiente (sin importar cuán profundo esté), como `ThemedButton`, puede "suscribirse" y acceder a esos valores directamente usando el Hook `useContext(ThemeContext)`.
4.  **Actualización:** Cuando `ThemedButton` llama a `toggleTheme`, el estado se actualiza en el `ThemeProvider`. Como el valor del `Provider` ha cambiado, React automáticamente vuelve a renderizar todos los componentes que consumen ese contexto (en este caso, `ThemedButton`) con el nuevo valor.
